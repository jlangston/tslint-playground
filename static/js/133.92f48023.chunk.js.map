{"version":3,"sources":["../node_modules/tslint/lib/rules/fileHeaderRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","text","headerFormat","RegExp","ruleArguments","textToInsert","offset","startsWith","indexOf","commentText","forEachLeadingCommentRange","pos","end","kind","substring","SyntaxKind","SingleLineCommentTrivia","undefined","test","isErrorAtStart","leadingNewlines","trailingNewlines","fix","Replacement","appendText","createComment","RuleFailure","FAILURE_STRING","ruleName","lineEnding","getLineEndOfPosition","repeat","concat","split","map","line","replace","join","metadata","description","optionsDescription","Utils","dedent","__makeTemplateObject","options","type","items","additionalItems","minLength","maxLength","optionExamples","hasFix","typescriptOnly","Rules","AbstractRule"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAsEAC,EAtEAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,IACAE,EAAAF,EAAA,MACAG,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KA6DA,OA/DAP,EAAAS,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,IAAAC,EAAAD,EAAAC,KACAC,EAAA,IAAAC,OAAAP,KAAAQ,cAAA,IACAC,EAAAT,KAAAQ,cAAA,GAEAE,EAAAL,EAAAM,WAAA,MAAAN,EAAAO,QAAA,QAEAC,EAAAlB,EAAAmB,2BAAAT,EAAAK,EAAA,SAAAK,EAAAC,EAAAC,GAAiG,OAAAZ,EAAAa,UAAAH,EAAA,EAAAE,IAAAtB,EAAAwB,WAAAC,wBAAAJ,IAAA,KACjG,QAAAK,IAAAR,IAAAP,EAAAgB,KAAAT,GAAA,CACA,IAAAU,EAAA,IAAAb,EACAa,KACAb,EAEA,IAAAc,EAAAD,EAAA,IACAE,EAAAF,EAAA,IACAG,OAAAL,IAAAZ,EACAb,EAAA+B,YAAAC,WAAAlB,EAAAV,KAAA6B,cAAAzB,EAAAK,EAAAe,EAAAC,SACAJ,EACA,WAAAzB,EAAAkC,YAAA1B,EAAAM,IAAAb,EAAAkC,eAAA/B,KAAAgC,SAAAN,IAEA,UAEA7B,EAAAM,UAAA0B,cAAA,SAAAzB,EAAAS,EAAAW,EAAAC,QACA,IAAAD,IAAyCA,EAAA,QACzC,IAAAC,IAA0CA,EAAA,GAC1C,IACAQ,GADA,OAAA7B,EAAAC,KAAAD,EAAA8B,qBAAA,aACA,KACA,OAAAD,EAAAE,OAAAX,IACA,OACAY,OAAAvB,EAAAwB,MAAA,UAAAC,IAAA,SAAAC,GAAkE,aAAAA,GAAAC,QAAA,cAClE,QACAC,KAAAR,KAAAE,OAAAV,IAGA5B,EAAA6C,UACAV,SAAA,cACAW,YAAA,oFACAC,mBAAAhD,EAAAiD,MAAAC,OAAAtD,MAAAC,EAAAsD,sBAAA,8mBACAC,SACAC,KAAA,QACAC,QAEAD,KAAA,WAGAA,KAAA,WAGAE,iBAAA,EACAC,UAAA,EACAC,UAAA,GAEAC,kBAAA,qBAAiD,mBACjDC,QAAA,EACAN,KAAA,QACAO,gBAAA,GAGA3D,EAAAkC,eAAA,sBACAlC,EAhEA,CAiECD,EAAA6D,MAAAC,cACDpE,EAAAO","file":"static/js/133.92f48023.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var text = sourceFile.text;\n        var headerFormat = new RegExp(this.ruleArguments[0]);\n        var textToInsert = this.ruleArguments[1];\n        // ignore shebang if it exists\n        var offset = text.startsWith(\"#!\") ? text.indexOf(\"\\n\") : 0;\n        // returns the text of the first comment or undefined\n        var commentText = ts.forEachLeadingCommentRange(text, offset, function (pos, end, kind) { return text.substring(pos + 2, kind === ts.SyntaxKind.SingleLineCommentTrivia ? end : end - 2); });\n        if (commentText === undefined || !headerFormat.test(commentText)) {\n            var isErrorAtStart = offset === 0;\n            if (!isErrorAtStart) {\n                ++offset; // show warning in next line after shebang\n            }\n            var leadingNewlines = isErrorAtStart ? 0 : 1;\n            var trailingNewlines = isErrorAtStart ? 2 : 1;\n            var fix = textToInsert !== undefined\n                ? Lint.Replacement.appendText(offset, this.createComment(sourceFile, textToInsert, leadingNewlines, trailingNewlines))\n                : undefined;\n            return [new Lint.RuleFailure(sourceFile, offset, offset, Rule.FAILURE_STRING, this.ruleName, fix)];\n        }\n        return [];\n    };\n    Rule.prototype.createComment = function (sourceFile, commentText, leadingNewlines, trailingNewlines) {\n        if (leadingNewlines === void 0) { leadingNewlines = 1; }\n        if (trailingNewlines === void 0) { trailingNewlines = 1; }\n        var maybeCarriageReturn = sourceFile.text[sourceFile.getLineEndOfPosition(0)] === \"\\r\" ? \"\\r\" : \"\";\n        var lineEnding = maybeCarriageReturn + \"\\n\";\n        return lineEnding.repeat(leadingNewlines) + [\n            \"/*!\"\n        ].concat(commentText.split(/\\r?\\n/g).map(function (line) { return (\" * \" + line).replace(/\\s+$/, \"\"); }), [\n            \" */\",\n        ]).join(lineEnding) + lineEnding.repeat(trailingNewlines);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"file-header\",\n        description: \"Enforces a certain header comment for all files, matched by a regular expression.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            The first option, which is mandatory, is a regular expression that all headers should match.\\n            The second argument, which is optional, is a string that should be inserted as a header comment\\n            if fixing is enabled and no header that matches the first argument is found.\"], [\"\\n            The first option, which is mandatory, is a regular expression that all headers should match.\\n            The second argument, which is optional, is a string that should be inserted as a header comment\\n            if fixing is enabled and no header that matches the first argument is found.\"]))),\n        options: {\n            type: \"array\",\n            items: [\n                {\n                    type: \"string\",\n                },\n                {\n                    type: \"string\",\n                },\n            ],\n            additionalItems: false,\n            minLength: 1,\n            maxLength: 2,\n        },\n        optionExamples: [[true, \"Copyright \\\\d{4}\", \"Copyright 2017\"]],\n        hasFix: true,\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"missing file header\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/fileHeaderRule.js\n// module id = 2026\n// module chunks = 133"],"sourceRoot":""}