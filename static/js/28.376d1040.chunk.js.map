{"version":3,"sources":["../node_modules/tslint/lib/rules/strictBooleanExpressionsRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","tsutils_1","ts","Lint","OPTION_ALLOW_NULL_UNION","OPTION_ALLOW_UNDEFINED_UNION","OPTION_ALLOW_STRING","OPTION_ALLOW_NUMBER","OPTION_ALLOW_MIX","OPTION_ALLOW_BOOLEAN_OR_UNDEFINED","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","options","ruleArguments","strictNullChecks","allowNullUnion","has","allowUndefinedUnion","allowString","allowNumber","allowMix","allowBooleanOrUndefined","name","indexOf","parseOptions","isStrictNullChecksEnabled","getCompilerOptions","applyWithFunction","walk","getTypeChecker","metadata","ruleName","description","Utils","dedent","__makeTemplateObject","optionsDescription","type","items","enum","minLength","maxLength","optionExamples","typescriptOnly","requiresTypeInfo","Rules","TypedRule","ctx","checker","checkExpression","node","location","getTypeAtLocation","failure","isUnionType","isTruthy","_i","_a","types","length","ty","isTypeFlagSet","TypeFlags","Boolean","BooleanLiteral","intrinsicName","Void","Undefined","isBooleanUndefined","anyTruthy","seenFalsy","kind","getKind","failureForKind","undefined","triState","handleUnion","Any","getTypeFailure","addFailureAtNode","unionType","expectedTypes","parts","push","showExpectedTypes","expected","res","i","stringOr","tyFail","is","showTypeFailure","n","SyntaxKind","PrefixUnaryExpression","ConditionalExpression","ForStatement","IfStatement","WhileStatement","DoStatement","BinaryExpression","binaryBooleanExpressionKind","showLocation","showFailure","forEachChild","cb","b_1","left","right","checkHalf","expr","isBooleanBinaryExpression","operator","operand","ExclamationToken","c","expression","condition","isInUnion","String","Number","Null","EnumLike","NumberLiteral","text","numberLiteralIsZero","StringLiteral","stringLiteralIsEmpty","flags","operatorToken","AmpersandAmpersandToken","BarBarToken","Union","Enum"],"mappings":"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","file":"static/js/28.376d1040.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_NULL_UNION = \"allow-null-union\";\nvar OPTION_ALLOW_UNDEFINED_UNION = \"allow-undefined-union\";\nvar OPTION_ALLOW_STRING = \"allow-string\";\nvar OPTION_ALLOW_NUMBER = \"allow-number\";\nvar OPTION_ALLOW_MIX = \"allow-mix\";\nvar OPTION_ALLOW_BOOLEAN_OR_UNDEFINED = \"allow-boolean-or-undefined\";\n// tslint:disable object-literal-sort-keys\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var options = parseOptions(this.ruleArguments, Lint.isStrictNullChecksEnabled(program.getCompilerOptions()));\n        return this.applyWithFunction(sourceFile, walk, options, program.getTypeChecker());\n    };\n    Rule.metadata = {\n        ruleName: \"strict-boolean-expressions\",\n        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Restricts the types allowed in boolean expressions. By default only booleans are allowed.\\n\\n            The following nodes are checked:\\n\\n            * Arguments to the `!`, `&&`, and `||` operators\\n            * The condition in a conditional expression (`cond ? x : y`)\\n            * Conditions for `if`, `for`, `while`, and `do-while` statements.\"], [\"\\n            Restricts the types allowed in boolean expressions. By default only booleans are allowed.\\n\\n            The following nodes are checked:\\n\\n            * Arguments to the \\\\`!\\\\`, \\\\`&&\\\\`, and \\\\`||\\\\` operators\\n            * The condition in a conditional expression (\\\\`cond ? x : y\\\\`)\\n            * Conditions for \\\\`if\\\\`, \\\\`for\\\\`, \\\\`while\\\\`, and \\\\`do-while\\\\` statements.\"]))),\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            These options may be provided:\\n\\n            * `\", \"` allows union types containing `null`.\\n              - It does *not* allow `null` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * `\", \"` allows union types containing `undefined`.\\n              - It does *not* allow `undefined` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * `\", \"` allows strings.\\n              - It does *not* allow unions containing `string`.\\n              - It does *not* allow string literal types.\\n            * `\", \"` allows numbers.\\n              - It does *not* allow unions containing `number`.\\n              - It does *not* allow enums or number literal types.\\n            * `\", \"` allows multiple of the above to appear together.\\n              - For example, `string | number` or `RegExp | null | undefined` would normally not be allowed.\\n              - A type like `\\\"foo\\\" | \\\"bar\\\" | undefined` is always allowed, because it has only one way to be false.\\n            * `\", \"` allows `boolean | undefined`.\\n              - Also allows `true | false | undefined`.\\n              - Does not allow `false | undefined`.\\n              - This option is a subset of `\", \"`, so you don't need to enable both options at the same time.\\n        \"], [\"\\n            These options may be provided:\\n\\n            * \\\\`\", \"\\\\` allows union types containing \\\\`null\\\\`.\\n              - It does *not* allow \\\\`null\\\\` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * \\\\`\", \"\\\\` allows union types containing \\\\`undefined\\\\`.\\n              - It does *not* allow \\\\`undefined\\\\` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * \\\\`\", \"\\\\` allows strings.\\n              - It does *not* allow unions containing \\\\`string\\\\`.\\n              - It does *not* allow string literal types.\\n            * \\\\`\", \"\\\\` allows numbers.\\n              - It does *not* allow unions containing \\\\`number\\\\`.\\n              - It does *not* allow enums or number literal types.\\n            * \\\\`\", \"\\\\` allows multiple of the above to appear together.\\n              - For example, \\\\`string | number\\\\` or \\\\`RegExp | null | undefined\\\\` would normally not be allowed.\\n              - A type like \\\\`\\\"foo\\\" | \\\"bar\\\" | undefined\\\\` is always allowed, because it has only one way to be false.\\n            * \\\\`\", \"\\\\` allows \\\\`boolean | undefined\\\\`.\\n              - Also allows \\\\`true | false | undefined\\\\`.\\n              - Does not allow \\\\`false | undefined\\\\`.\\n              - This option is a subset of \\\\`\", \"\\\\`, so you don't need to enable both options at the same time.\\n        \"])), OPTION_ALLOW_NULL_UNION, OPTION_ALLOW_UNDEFINED_UNION, OPTION_ALLOW_STRING, OPTION_ALLOW_NUMBER, OPTION_ALLOW_MIX, OPTION_ALLOW_BOOLEAN_OR_UNDEFINED, OPTION_ALLOW_UNDEFINED_UNION),\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    OPTION_ALLOW_NULL_UNION,\n                    OPTION_ALLOW_UNDEFINED_UNION,\n                    OPTION_ALLOW_STRING,\n                    OPTION_ALLOW_NUMBER,\n                    OPTION_ALLOW_BOOLEAN_OR_UNDEFINED,\n                ],\n            },\n            minLength: 0,\n            maxLength: 5,\n        },\n        optionExamples: [\n            true,\n            [true, OPTION_ALLOW_NULL_UNION, OPTION_ALLOW_UNDEFINED_UNION, OPTION_ALLOW_STRING, OPTION_ALLOW_NUMBER],\n            [true, OPTION_ALLOW_BOOLEAN_OR_UNDEFINED],\n        ],\n        type: \"functionality\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments, strictNullChecks) {\n    return {\n        strictNullChecks: strictNullChecks,\n        allowNullUnion: has(OPTION_ALLOW_NULL_UNION),\n        allowUndefinedUnion: has(OPTION_ALLOW_UNDEFINED_UNION),\n        allowString: has(OPTION_ALLOW_STRING),\n        allowNumber: has(OPTION_ALLOW_NUMBER),\n        allowMix: has(OPTION_ALLOW_MIX),\n        allowBooleanOrUndefined: has(OPTION_ALLOW_BOOLEAN_OR_UNDEFINED),\n    };\n    function has(name) {\n        return ruleArguments.indexOf(name) !== -1;\n    }\n}\nfunction walk(ctx, checker) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.BinaryExpression: {\n                var b_1 = node;\n                if (binaryBooleanExpressionKind(b_1) !== undefined) {\n                    var left = b_1.left, right = b_1.right;\n                    var checkHalf = function (expr) {\n                        // If it's another boolean binary expression, we'll check it when recursing.\n                        if (!isBooleanBinaryExpression(expr)) {\n                            checkExpression(expr, b_1);\n                        }\n                    };\n                    checkHalf(left);\n                    checkHalf(right);\n                }\n                break;\n            }\n            case ts.SyntaxKind.PrefixUnaryExpression: {\n                var _a = node, operator = _a.operator, operand = _a.operand;\n                if (operator === ts.SyntaxKind.ExclamationToken) {\n                    checkExpression(operand, node);\n                }\n                break;\n            }\n            case ts.SyntaxKind.IfStatement:\n            case ts.SyntaxKind.WhileStatement:\n            case ts.SyntaxKind.DoStatement: {\n                var c = node;\n                // If it's a boolean binary expression, we'll check it when recursing.\n                if (!isBooleanBinaryExpression(c.expression)) {\n                    checkExpression(c.expression, c);\n                }\n                break;\n            }\n            case ts.SyntaxKind.ConditionalExpression:\n                checkExpression(node.condition, node);\n                break;\n            case ts.SyntaxKind.ForStatement: {\n                var condition = node.condition;\n                if (condition !== undefined) {\n                    checkExpression(condition, node);\n                }\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkExpression(node, location) {\n        var type = checker.getTypeAtLocation(node);\n        var failure = getTypeFailure(type, options);\n        if (failure !== undefined) {\n            if (failure === 0 /* AlwaysTruthy */ &&\n                !options.strictNullChecks &&\n                (options.allowNullUnion || options.allowUndefinedUnion)) {\n                // OK; It might be null/undefined.\n                return;\n            }\n            ctx.addFailureAtNode(node, showFailure(location, failure, isUnionType(type), options));\n        }\n    }\n}\nfunction getTypeFailure(type, options) {\n    if (isUnionType(type)) {\n        return handleUnion(type, options);\n    }\n    var kind = getKind(type);\n    var failure = failureForKind(kind, /*isInUnion*/ false, options);\n    if (failure !== undefined) {\n        return failure;\n    }\n    switch (triState(kind)) {\n        case true:\n            // Allow 'any'. Allow 'true' itself, but not any other always-truthy type.\n            // tslint:disable-next-line no-bitwise\n            return tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Any | ts.TypeFlags.BooleanLiteral) ? undefined : 0 /* AlwaysTruthy */;\n        case false:\n            // Allow 'false' itself, but not any other always-falsy type\n            return tsutils_1.isTypeFlagSet(type, ts.TypeFlags.BooleanLiteral) ? undefined : 1 /* AlwaysFalsy */;\n        case undefined:\n            return undefined;\n    }\n}\nfunction isBooleanUndefined(type) {\n    var isTruthy = false;\n    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {\n        var ty = _a[_i];\n        if (tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.Boolean)) {\n            isTruthy = true;\n        }\n        else if (tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.BooleanLiteral)) {\n            isTruthy = isTruthy || ty.intrinsicName === \"true\";\n        }\n        else if (!tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.Void | ts.TypeFlags.Undefined)) { // tslint:disable-line:no-bitwise\n            return undefined;\n        }\n    }\n    return isTruthy;\n}\nfunction handleUnion(type, options) {\n    if (options.allowBooleanOrUndefined) {\n        switch (isBooleanUndefined(type)) {\n            case true:\n                return undefined;\n            case false:\n                return 1 /* AlwaysFalsy */;\n        }\n    }\n    // Tracks whether it's possibly truthy.\n    var anyTruthy = false;\n    // Counts falsy kinds to see if there's a mix. Also tracks whether it's possibly falsy.\n    var seenFalsy = 0;\n    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {\n        var ty = _a[_i];\n        var kind = getKind(ty);\n        var failure = failureForKind(kind, /*isInUnion*/ true, options);\n        if (failure !== undefined) {\n            return failure;\n        }\n        switch (triState(kind)) {\n            case true:\n                anyTruthy = true;\n                break;\n            case false:\n                seenFalsy++;\n                break;\n            default:\n                anyTruthy = true;\n                seenFalsy++;\n        }\n    }\n    return seenFalsy === 0 ? 0 /* AlwaysTruthy */\n        : !anyTruthy ? 1 /* AlwaysFalsy */\n            : !options.allowMix && seenFalsy > 1 ? 7 /* Mixes */ : undefined;\n}\n/** Fails if a kind of falsiness is not allowed. */\nfunction failureForKind(kind, isInUnion, options) {\n    switch (kind) {\n        case 0 /* String */:\n        case 1 /* FalseStringLiteral */:\n            return options.allowString ? undefined : 2 /* String */;\n        case 2 /* Number */:\n        case 3 /* FalseNumberLiteral */:\n            return options.allowNumber ? undefined : 3 /* Number */;\n        case 8 /* Enum */:\n            return 6 /* Enum */;\n        case 6 /* Null */:\n            return isInUnion && !options.allowNullUnion ? 4 /* Null */ : undefined;\n        case 7 /* Undefined */:\n            return isInUnion && !options.allowUndefinedUnion ? 5 /* Undefined */ : undefined;\n        default:\n            return undefined;\n    }\n}\n/** Divides a type into always true, always false, or unknown. */\nfunction triState(kind) {\n    switch (kind) {\n        case 0 /* String */:\n        case 2 /* Number */:\n        case 4 /* Boolean */:\n        case 8 /* Enum */:\n            return undefined;\n        case 6 /* Null */:\n        case 7 /* Undefined */:\n        case 3 /* FalseNumberLiteral */:\n        case 1 /* FalseStringLiteral */:\n        case 5 /* FalseBooleanLiteral */:\n            return false;\n        case 9 /* AlwaysTruthy */:\n            return true;\n    }\n}\nfunction getKind(type) {\n    return is(ts.TypeFlags.String) ? 0 /* String */\n        : is(ts.TypeFlags.Number) ? 2 /* Number */\n            : is(ts.TypeFlags.Boolean) ? 4 /* Boolean */\n                : is(ts.TypeFlags.Null) ? 6 /* Null */\n                    : is(ts.TypeFlags.Undefined | ts.TypeFlags.Void) ? 7 /* Undefined */\n                        : is(ts.TypeFlags.EnumLike) ? 8 /* Enum */\n                            : is(ts.TypeFlags.NumberLiteral) ?\n                                (numberLiteralIsZero(type) ? 3 /* FalseNumberLiteral */ : 9 /* AlwaysTruthy */)\n                                : is(ts.TypeFlags.StringLiteral) ?\n                                    (stringLiteralIsEmpty(type) ? 1 /* FalseStringLiteral */ : 9 /* AlwaysTruthy */)\n                                    : is(ts.TypeFlags.BooleanLiteral) ?\n                                        (type.intrinsicName === \"true\" ? 9 /* AlwaysTruthy */ : 5 /* FalseBooleanLiteral */)\n                                        : 9 /* AlwaysTruthy */;\n    function is(flags) {\n        return tsutils_1.isTypeFlagSet(type, flags);\n    }\n}\nfunction numberLiteralIsZero(type) {\n    // for compatibility with typescript@<2.4.0\n    return type.value !== undefined ? type.value === 0 : type.text === \"0\";\n}\nfunction stringLiteralIsEmpty(type) {\n    // for compatibility with typescript@<2.4.0\n    return (type.value !== undefined ? type.value : type.text) === \"\";\n}\n/** Matches `&&` and `||` operators. */\nfunction isBooleanBinaryExpression(node) {\n    return node.kind === ts.SyntaxKind.BinaryExpression && binaryBooleanExpressionKind(node) !== undefined;\n}\nfunction binaryBooleanExpressionKind(node) {\n    switch (node.operatorToken.kind) {\n        case ts.SyntaxKind.AmpersandAmpersandToken:\n            return \"&&\";\n        case ts.SyntaxKind.BarBarToken:\n            return \"||\";\n        default:\n            return undefined;\n    }\n}\nfunction stringOr(parts) {\n    switch (parts.length) {\n        case 1:\n            return parts[0];\n        case 2:\n            return parts[0] + \" or \" + parts[1];\n        default:\n            var res = \"\";\n            for (var i = 0; i < parts.length - 1; i++) {\n                res += parts[i] + \", \";\n            }\n            return res + \"or \" + parts[parts.length - 1];\n    }\n}\nfunction isUnionType(type) {\n    return tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Union) && !tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Enum);\n}\nfunction showLocation(n) {\n    switch (n.kind) {\n        case ts.SyntaxKind.PrefixUnaryExpression:\n            return \"operand for the '!' operator\";\n        case ts.SyntaxKind.ConditionalExpression:\n            return \"condition\";\n        case ts.SyntaxKind.ForStatement:\n            return \"'for' condition\";\n        case ts.SyntaxKind.IfStatement:\n            return \"'if' condition\";\n        case ts.SyntaxKind.WhileStatement:\n            return \"'while' condition\";\n        case ts.SyntaxKind.DoStatement:\n            return \"'do-while' condition\";\n        case ts.SyntaxKind.BinaryExpression:\n            return \"operand for the '\" + binaryBooleanExpressionKind(n) + \"' operator\";\n    }\n}\nfunction showFailure(location, ty, unionType, options) {\n    var expectedTypes = showExpectedTypes(options);\n    var expected = expectedTypes.length === 1\n        ? \"Only \" + expectedTypes[0] + \"s are allowed\"\n        : \"Allowed types are \" + stringOr(expectedTypes);\n    var tyFail = showTypeFailure(ty, unionType, options.strictNullChecks);\n    return \"This type is not allowed in the \" + showLocation(location) + \" because it \" + tyFail + \". \" + expected + \".\";\n}\nfunction showExpectedTypes(options) {\n    var parts = [\"boolean\"];\n    if (options.allowNullUnion) {\n        parts.push(\"null-union\");\n    }\n    if (options.allowUndefinedUnion) {\n        parts.push(\"undefined-union\");\n    }\n    if (options.allowString) {\n        parts.push(\"string\");\n    }\n    if (options.allowNumber) {\n        parts.push(\"number\");\n    }\n    if (options.allowBooleanOrUndefined) {\n        parts.push(\"boolean-or-undefined\");\n    }\n    return parts;\n}\nfunction showTypeFailure(ty, unionType, strictNullChecks) {\n    var is = unionType ? \"could be\" : \"is\";\n    switch (ty) {\n        case 0 /* AlwaysTruthy */:\n            return strictNullChecks\n                ? \"is always truthy\"\n                : \"is always truthy. It may be null/undefined, but neither \" +\n                    (\"'\" + OPTION_ALLOW_NULL_UNION + \"' nor '\" + OPTION_ALLOW_UNDEFINED_UNION + \"' is set\");\n        case 1 /* AlwaysFalsy */: return \"is always falsy\";\n        case 2 /* String */: return is + \" a string\";\n        case 3 /* Number */: return is + \" a number\";\n        case 4 /* Null */: return is + \" null\";\n        case 5 /* Undefined */: return is + \" undefined\";\n        case 6 /* Enum */: return is + \" an enum\";\n        case 7 /* Mixes */: return \"unions more than one truthy/falsy type\";\n    }\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/strictBooleanExpressionsRule.js\n// module id = 2136\n// module chunks = 28"],"sourceRoot":""}