{"version":3,"sources":["../node_modules/tslint/lib/rules/typedefRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","utils","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithWalker","TypedefWalker","ruleName","ruleArguments","options","_i","ruleArguments_1","length","parseOptions","metadata","description","optionsDescription","Utils","dedent","templateObject_1","__makeTemplateObject","type","items","enum","minLength","maxLength","optionExamples","typescriptOnly","Rules","AbstractRule","walk","_this","cb","node","kind","SyntaxKind","FunctionDeclaration","FunctionExpression","GetAccessor","MethodDeclaration","MethodSignature","_a","name","parameters","checkTypeAnnotation","undefined","ArrowFunction","checkArrowFunction","Parameter","checkParameter","PropertyDeclaration","checkPropertyDeclaration","PropertySignature","_b","VariableDeclaration","checkVariableDeclaration","forEachChild","parent","CallExpression","isTypedPropertyDeclaration","option","isPropertyDeclaration","initializer","CatchClause","ForInStatement","ForOfStatement","ObjectBindingPattern","ArrayBindingPattern","location","typeAnnotation","failure","getText","isNodeArray","addFailure","pos","end","addFailureAtNode","AbstractWalker","nodeOrArray","Array","isArray"],"mappings":"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","file":"static/js/21.90d7ef03.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_CALL_SIGNATURE = \"call-signature\";\nvar OPTION_ARROW_CALL_SIGNATURE = \"arrow-call-signature\";\nvar OPTION_PARAMETER = \"parameter\";\nvar OPTION_ARROW_PARAMETER = \"arrow-parameter\";\nvar OPTION_PROPERTY_DECLARATION = \"property-declaration\";\nvar OPTION_VARIABLE_DECLARATION = \"variable-declaration\";\nvar OPTION_MEMBER_VARIABLE_DECLARATION = \"member-variable-declaration\";\nvar OPTION_OBJECT_DESTRUCTURING = \"object-destructuring\";\nvar OPTION_ARRAY_DESTRUCTURING = \"array-destructuring\";\nfunction parseOptions(ruleArguments) {\n    var options = {};\n    for (var _i = 0, ruleArguments_1 = ruleArguments; _i < ruleArguments_1.length; _i++) {\n        var arg = ruleArguments_1[_i];\n        options[arg] = true;\n    }\n    return options;\n}\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new TypedefWalker(sourceFile, this.ruleName, parseOptions(this.ruleArguments)));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"typedef\",\n        description: \"Requires type definitions to exist.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Several arguments may be optionally provided:\\n\\n            * `\\\"\", \"\\\"` checks return type of functions.\\n            * `\\\"\", \"\\\"` checks return type of arrow functions.\\n            * `\\\"\", \"\\\"` checks type specifier of function parameters for non-arrow functions.\\n            * `\\\"\", \"\\\"` checks type specifier of function parameters for arrow functions.\\n            * `\\\"\", \"\\\"` checks return types of interface properties.\\n            * `\\\"\", \"\\\"` checks non-binding variable declarations.\\n            * `\\\"\", \"\\\"` checks member variable declarations.\\n            * `\\\"\", \"\\\"` checks object destructuring declarations.\\n            * `\\\"\", \"\\\"` checks array destructuring declarations.\"], [\"\\n            Several arguments may be optionally provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` checks return type of functions.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks return type of arrow functions.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks type specifier of function parameters for non-arrow functions.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks type specifier of function parameters for arrow functions.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks return types of interface properties.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks non-binding variable declarations.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks member variable declarations.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks object destructuring declarations.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks array destructuring declarations.\"])), OPTION_CALL_SIGNATURE, OPTION_ARROW_CALL_SIGNATURE, OPTION_PARAMETER, OPTION_ARROW_PARAMETER, OPTION_PROPERTY_DECLARATION, OPTION_VARIABLE_DECLARATION, OPTION_MEMBER_VARIABLE_DECLARATION, OPTION_OBJECT_DESTRUCTURING, OPTION_ARRAY_DESTRUCTURING),\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    OPTION_CALL_SIGNATURE,\n                    OPTION_ARROW_CALL_SIGNATURE,\n                    OPTION_PARAMETER,\n                    OPTION_ARROW_PARAMETER,\n                    OPTION_PROPERTY_DECLARATION,\n                    OPTION_VARIABLE_DECLARATION,\n                    OPTION_MEMBER_VARIABLE_DECLARATION,\n                    OPTION_OBJECT_DESTRUCTURING,\n                    OPTION_ARRAY_DESTRUCTURING,\n                ],\n            },\n            minLength: 0,\n            maxLength: 7,\n        },\n        optionExamples: [[true, OPTION_CALL_SIGNATURE, OPTION_PARAMETER, OPTION_MEMBER_VARIABLE_DECLARATION]],\n        type: \"typescript\",\n        typescriptOnly: true,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar TypedefWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(TypedefWalker, _super);\n    function TypedefWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TypedefWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            switch (node.kind) {\n                case ts.SyntaxKind.FunctionDeclaration:\n                case ts.SyntaxKind.FunctionExpression:\n                case ts.SyntaxKind.GetAccessor:\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.MethodSignature: {\n                    var _a = node, name = _a.name, parameters = _a.parameters, type = _a.type;\n                    _this.checkTypeAnnotation(\"call-signature\", name !== undefined ? name : parameters, type, name);\n                    break;\n                }\n                case ts.SyntaxKind.ArrowFunction:\n                    _this.checkArrowFunction(node);\n                    break;\n                case ts.SyntaxKind.Parameter:\n                    _this.checkParameter(node);\n                    break;\n                case ts.SyntaxKind.PropertyDeclaration:\n                    _this.checkPropertyDeclaration(node);\n                    break;\n                case ts.SyntaxKind.PropertySignature: {\n                    var _b = node, name = _b.name, type = _b.type;\n                    _this.checkTypeAnnotation(\"property-declaration\", name, type, name);\n                    break;\n                }\n                case ts.SyntaxKind.VariableDeclaration:\n                    _this.checkVariableDeclaration(node);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    TypedefWalker.prototype.checkArrowFunction = function (_a) {\n        var parent = _a.parent, parameters = _a.parameters, type = _a.type;\n        if (parent.kind !== ts.SyntaxKind.CallExpression && !isTypedPropertyDeclaration(parent)) {\n            this.checkTypeAnnotation(\"arrow-call-signature\", parameters, type);\n        }\n    };\n    TypedefWalker.prototype.checkParameter = function (_a) {\n        var parent = _a.parent, name = _a.name, type = _a.type;\n        var isArrowFunction = parent.kind === ts.SyntaxKind.ArrowFunction;\n        var option = (function () {\n            if (!isArrowFunction) {\n                return \"parameter\";\n            }\n            else if (isTypedPropertyDeclaration(parent.parent)) {\n                return undefined;\n            }\n            else if (utils.isPropertyDeclaration(parent.parent)) {\n                return \"member-variable-declaration\";\n            }\n            else {\n                return \"arrow-parameter\";\n            }\n        })();\n        if (option !== undefined) {\n            this.checkTypeAnnotation(option, name, type, name);\n        }\n    };\n    TypedefWalker.prototype.checkPropertyDeclaration = function (_a) {\n        var initializer = _a.initializer, name = _a.name, type = _a.type;\n        // If this is an arrow function, it doesn't need to have a typedef on the property declaration\n        // as the typedefs can be on the function's parameters instead\n        if (initializer === undefined || initializer.kind !== ts.SyntaxKind.ArrowFunction) {\n            this.checkTypeAnnotation(\"member-variable-declaration\", name, type, name);\n        }\n    };\n    TypedefWalker.prototype.checkVariableDeclaration = function (_a) {\n        var parent = _a.parent, name = _a.name, type = _a.type;\n        // variable declarations should always have a grandparent, but check that to be on the safe side.\n        // catch statements will be the parent of the variable declaration\n        // for-in/for-of loops will be the gradparent of the variable declaration\n        if (parent.kind === ts.SyntaxKind.CatchClause\n            || parent.parent.kind === ts.SyntaxKind.ForInStatement\n            || parent.parent.kind === ts.SyntaxKind.ForOfStatement) {\n            return;\n        }\n        var option = (function () {\n            switch (name.kind) {\n                case ts.SyntaxKind.ObjectBindingPattern:\n                    return \"object-destructuring\";\n                case ts.SyntaxKind.ArrayBindingPattern:\n                    return \"array-destructuring\";\n                default:\n                    return \"variable-declaration\";\n            }\n        })();\n        this.checkTypeAnnotation(option, name, type, name);\n    };\n    TypedefWalker.prototype.checkTypeAnnotation = function (option, location, typeAnnotation, name) {\n        if (this.options[option] === true && typeAnnotation === undefined) {\n            var failure = \"expected \" + option + (name === undefined ? \"\" : \": '\" + name.getText() + \"'\") + \" to have a typedef\";\n            if (isNodeArray(location)) {\n                this.addFailure(location.pos - 1, location.end + 1, failure);\n            }\n            else {\n                this.addFailureAtNode(location, failure);\n            }\n        }\n    };\n    return TypedefWalker;\n}(Lint.AbstractWalker));\nfunction isTypedPropertyDeclaration(node) {\n    return utils.isPropertyDeclaration(node) && node.type !== undefined;\n}\nfunction isNodeArray(nodeOrArray) {\n    return Array.isArray(nodeOrArray);\n}\nexports.isNodeArray = isNodeArray;\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/typedefRule.js\n// module id = 2144\n// module chunks = 21"],"sourceRoot":""}