{"version":3,"sources":["../node_modules/tslint/lib/rules/orderedImportsRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithWalker","Walker","ruleName","ruleArguments","optionSet","_b","_a","undefined","isGrouped","_c","sources","_d","named","_e","path","groupedImports","importSourcesOrderTransform","TRANSFORMS","get","moduleSourcePath","namedImportsOrderTransform","metadata","description","descriptionDetails","Utils","dedent","templateObject_1","__makeTemplateObject","hasFix","optionsDescription","templateObject_2","options","type","properties","grouped-imports","import-sources-order","enum","named-imports-order","module-source-path","additionalProperties","optionExamples","typescriptOnly","IMPORT_SOURCES_NOT_GROUPED","IMPORT_SOURCES_UNORDERED","NAMED_IMPORTS_UNORDERED","Rules","AbstractRule","ImportType","Map","x","toLowerCase","str","Array","from","map","char","toUpperCase","join","isExternalModuleNameRelative","splitIndex","lastIndexOf","substr","_this","importsBlocks","ImportsBlock","nextType","LIBRARY_IMPORT","length","enumerable","configurable","walk","_i","statements","statement","checkStatement","endBlock","checkBlocksGrouping","isImportDeclaration","isImportEqualsDeclaration","test","text","slice","getFullStart","getStart","checkImportDeclaration","checkImportEqualsDeclaration","isModuleDeclaration","body","node","kind","SyntaxKind","ModuleDeclaration","ModuleBlock","moduleDeclarationBody","subStatement","isStringLiteral","moduleSpecifier","source","removeQuotes","checkSource","importClause","namedBindings","isNamedImports","checkNamedImports","moduleReference","isExternalModuleReference","expression","currentSource","previousSource","currentImportsBlock","getLastImportSource","addImportDeclaration","compare","lastFix","addFailureAtNode","replacement","getReplacement","push","imports","elements","pair","xs","transform","i","getText","findUnsortedPair","a","b","sortedDeclarations","sortByKey","start","replaceNamedImports","addFailure","getEnd","some","checkBlockGroups","importsBlock","oddImportDeclaration","getOddImportDeclaration","getReplacements","importDeclarations","getImportDeclarations","find","importDeclaration","importDeclarationsList","block","filter","allImportDeclarations","concat","replacements","getReplacementsForExistingImports","startOffset","nodeStartOffset","Replacement","appendText","getGroupedImports","items","index","prevItems","last","nodeEndOffset","deleteFromTo","PARENT_DIRECTORY_IMPORT","CURRENT_DIRECTORY_IMPORT","getSortedImportDeclarationsAsText","getEolChar","newLine","lineEnd","getLineEndOfPosition","sys","AbstractWalker","sourcePath","getStartOffset","end","getEndOffset","substring","getImportType","fileOffset","getLastImportDeclaration","Error","initialText","fixedText","indexOf","charAt","isLow","getSortKey","sort"],"mappings":"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","file":"static/js/45.056e2484.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.ruleName, parseOptions(this.ruleArguments)));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"ordered-imports\",\n        description: \"Requires that import statements be alphabetized and grouped.\",\n        descriptionDetails: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Enforce a consistent ordering for ES6 imports:\\n            - Named imports must be alphabetized (i.e. \\\"import {A, B, C} from \\\"foo\\\";\\\")\\n                - The exact ordering can be controlled by the named-imports-order option.\\n                - \\\"longName as name\\\" imports are ordered by \\\"longName\\\".\\n            - Import sources must be alphabetized within groups, i.e.:\\n                    import * as foo from \\\"a\\\";\\n                    import * as bar from \\\"b\\\";\\n            - Groups of imports are delineated by blank lines. You can use these to group imports\\n                however you like, e.g. by first- vs. third-party or thematically or can you can\\n                enforce a grouping of third-party, parent directories and the current directory.\"], [\"\\n            Enforce a consistent ordering for ES6 imports:\\n            - Named imports must be alphabetized (i.e. \\\"import {A, B, C} from \\\"foo\\\";\\\")\\n                - The exact ordering can be controlled by the named-imports-order option.\\n                - \\\"longName as name\\\" imports are ordered by \\\"longName\\\".\\n            - Import sources must be alphabetized within groups, i.e.:\\n                    import * as foo from \\\"a\\\";\\n                    import * as bar from \\\"b\\\";\\n            - Groups of imports are delineated by blank lines. You can use these to group imports\\n                however you like, e.g. by first- vs. third-party or thematically or can you can\\n                enforce a grouping of third-party, parent directories and the current directory.\"]))),\n        hasFix: true,\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            You may set the `\\\"import-sources-order\\\"` option to control the ordering of source\\n            imports (the `\\\"foo\\\"` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"import-sources-order\\\"` are:\\n\\n            * `\\\"case-insensitive'`: Correct order is `\\\"Bar\\\"`, `\\\"baz\\\"`, `\\\"Foo\\\"`. (This is the default.)\\n            * `\\\"lowercase-first\\\"`: Correct order is `\\\"baz\\\"`, `\\\"Bar\\\"`, `\\\"Foo\\\"`.\\n            * `\\\"lowercase-last\\\"`: Correct order is `\\\"Bar\\\"`, `\\\"Foo\\\"`, `\\\"baz\\\"`.\\n            * `\\\"any\\\"`: Allow any order.\\n\\n            You may set the `\\\"grouped-imports\\\"` option to control the grouping of source\\n            imports (the `\\\"foo\\\"` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"grouped-imports\\\"` are:\\n\\n            * `false`: Do not enforce grouping. (This is the default.)\\n            * `true`: Group source imports by `\\\"bar\\\"`, `\\\"../baz\\\"`, `\\\"./foo\\\"`.\\n\\n            You may set the `\\\"named-imports-order\\\"` option to control the ordering of named\\n            imports (the `{A, B, C}` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"named-imports-order\\\"` are:\\n\\n            * `\\\"case-insensitive'`: Correct order is `{A, b, C}`. (This is the default.)\\n            * `\\\"lowercase-first\\\"`: Correct order is `{b, A, C}`.\\n            * `\\\"lowercase-last\\\"`: Correct order is `{A, C, b}`.\\n            * `\\\"any\\\"`: Allow any order.\\n\\n            You may set the `\\\"module-source-path\\\"` option to control the ordering of imports based full path\\n            or just the module name\\n\\n            Possible values for `\\\"module-source-path\\\"` are:\\n\\n            * `\\\"full'`: Correct order is  `\\\"./a/Foo\\\"`, `\\\"./b/baz\\\"`, `\\\"./c/Bar\\\"`. (This is the default.)\\n            * `\\\"basename\\\"`: Correct order is `\\\"./c/Bar\\\"`, `\\\"./b/baz\\\"`, `\\\"./a/Foo\\\"`.\\n\\n        \"], [\"\\n            You may set the \\\\`\\\"import-sources-order\\\"\\\\` option to control the ordering of source\\n            imports (the \\\\`\\\"foo\\\"\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"import-sources-order\\\"\\\\` are:\\n\\n            * \\\\`\\\"case-insensitive'\\\\`: Correct order is \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"baz\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`. (This is the default.)\\n            * \\\\`\\\"lowercase-first\\\"\\\\`: Correct order is \\\\`\\\"baz\\\"\\\\`, \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`.\\n            * \\\\`\\\"lowercase-last\\\"\\\\`: Correct order is \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`, \\\\`\\\"baz\\\"\\\\`.\\n            * \\\\`\\\"any\\\"\\\\`: Allow any order.\\n\\n            You may set the \\\\`\\\"grouped-imports\\\"\\\\` option to control the grouping of source\\n            imports (the \\\\`\\\"foo\\\"\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"grouped-imports\\\"\\\\` are:\\n\\n            * \\\\`false\\\\`: Do not enforce grouping. (This is the default.)\\n            * \\\\`true\\\\`: Group source imports by \\\\`\\\"bar\\\"\\\\`, \\\\`\\\"../baz\\\"\\\\`, \\\\`\\\"./foo\\\"\\\\`.\\n\\n            You may set the \\\\`\\\"named-imports-order\\\"\\\\` option to control the ordering of named\\n            imports (the \\\\`{A, B, C}\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"named-imports-order\\\"\\\\` are:\\n\\n            * \\\\`\\\"case-insensitive'\\\\`: Correct order is \\\\`{A, b, C}\\\\`. (This is the default.)\\n            * \\\\`\\\"lowercase-first\\\"\\\\`: Correct order is \\\\`{b, A, C}\\\\`.\\n            * \\\\`\\\"lowercase-last\\\"\\\\`: Correct order is \\\\`{A, C, b}\\\\`.\\n            * \\\\`\\\"any\\\"\\\\`: Allow any order.\\n\\n            You may set the \\\\`\\\"module-source-path\\\"\\\\` option to control the ordering of imports based full path\\n            or just the module name\\n\\n            Possible values for \\\\`\\\"module-source-path\\\"\\\\` are:\\n\\n            * \\\\`\\\"full'\\\\`: Correct order is  \\\\`\\\"./a/Foo\\\"\\\\`, \\\\`\\\"./b/baz\\\"\\\\`, \\\\`\\\"./c/Bar\\\"\\\\`. (This is the default.)\\n            * \\\\`\\\"basename\\\"\\\\`: Correct order is \\\\`\\\"./c/Bar\\\"\\\\`, \\\\`\\\"./b/baz\\\"\\\\`, \\\\`\\\"./a/Foo\\\"\\\\`.\\n\\n        \"]))),\n        options: {\n            type: \"object\",\n            properties: {\n                \"grouped-imports\": {\n                    type: \"boolean\",\n                },\n                \"import-sources-order\": {\n                    type: \"string\",\n                    enum: [\"case-insensitive\", \"lowercase-first\", \"lowercase-last\", \"any\"],\n                },\n                \"named-imports-order\": {\n                    type: \"string\",\n                    enum: [\"case-insensitive\", \"lowercase-first\", \"lowercase-last\", \"any\"],\n                },\n                \"module-source-path\": {\n                    type: \"string\",\n                    enum: [\"full\", \"basename\"],\n                },\n            },\n            additionalProperties: false,\n        },\n        optionExamples: [\n            true,\n            [true, { \"import-sources-order\": \"lowercase-last\", \"named-imports-order\": \"lowercase-first\" }],\n        ],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.IMPORT_SOURCES_NOT_GROUPED = \"Import sources of different groups must be sorted by: libraries, parent directories, current directory.\";\n    Rule.IMPORT_SOURCES_UNORDERED = \"Import sources within a group must be alphabetized.\";\n    Rule.NAMED_IMPORTS_UNORDERED = \"Named imports must be alphabetized.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar TRANSFORMS = new Map([\n    [\"any\", function () { return \"\"; }],\n    [\"case-insensitive\", function (x) { return x.toLowerCase(); }],\n    [\"lowercase-first\", flipCase],\n    [\"lowercase-last\", function (x) { return x; }],\n    [\"full\", function (x) { return x; }],\n    [\"basename\", function (x) {\n            if (!ts.isExternalModuleNameRelative(x)) {\n                return x;\n            }\n            var splitIndex = x.lastIndexOf(\"/\");\n            if (splitIndex === -1) {\n                return x;\n            }\n            return x.substr(splitIndex + 1);\n        }],\n]);\nvar ImportType;\n(function (ImportType) {\n    ImportType[ImportType[\"LIBRARY_IMPORT\"] = 1] = \"LIBRARY_IMPORT\";\n    ImportType[ImportType[\"PARENT_DIRECTORY_IMPORT\"] = 2] = \"PARENT_DIRECTORY_IMPORT\";\n    ImportType[ImportType[\"CURRENT_DIRECTORY_IMPORT\"] = 3] = \"CURRENT_DIRECTORY_IMPORT\";\n})(ImportType || (ImportType = {}));\nfunction parseOptions(ruleArguments) {\n    var optionSet = ruleArguments[0];\n    var _a = optionSet === undefined ? {} : optionSet, _b = _a[\"grouped-imports\"], isGrouped = _b === void 0 ? false : _b, _c = _a[\"import-sources-order\"], sources = _c === void 0 ? \"case-insensitive\" : _c, _d = _a[\"named-imports-order\"], named = _d === void 0 ? \"case-insensitive\" : _d, _e = _a[\"module-source-path\"], path = _e === void 0 ? \"full\" : _e;\n    return {\n        groupedImports: isGrouped,\n        importSourcesOrderTransform: TRANSFORMS.get(sources),\n        moduleSourcePath: TRANSFORMS.get(path),\n        namedImportsOrderTransform: TRANSFORMS.get(named),\n    };\n}\nvar Walker = /** @class */ (function (_super) {\n    tslib_1.__extends(Walker, _super);\n    function Walker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.importsBlocks = [new ImportsBlock()];\n        _this.nextType = ImportType.LIBRARY_IMPORT;\n        return _this;\n    }\n    Object.defineProperty(Walker.prototype, \"currentImportsBlock\", {\n        get: function () {\n            return this.importsBlocks[this.importsBlocks.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Walker.prototype.walk = function (sourceFile) {\n        for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {\n            var statement = _a[_i];\n            this.checkStatement(statement);\n        }\n        this.endBlock();\n        if (this.options.groupedImports) {\n            this.checkBlocksGrouping();\n        }\n    };\n    Walker.prototype.checkStatement = function (statement) {\n        if (!(tsutils_1.isImportDeclaration(statement) || tsutils_1.isImportEqualsDeclaration(statement)) ||\n            /\\r?\\n\\r?\\n/.test(this.sourceFile.text.slice(statement.getFullStart(), statement.getStart(this.sourceFile)))) {\n            this.endBlock();\n        }\n        if (tsutils_1.isImportDeclaration(statement)) {\n            this.checkImportDeclaration(statement);\n        }\n        else if (tsutils_1.isImportEqualsDeclaration(statement)) {\n            this.checkImportEqualsDeclaration(statement);\n        }\n        else if (tsutils_1.isModuleDeclaration(statement)) {\n            var body = moduleDeclarationBody(statement);\n            if (body !== undefined) {\n                for (var _i = 0, _a = body.statements; _i < _a.length; _i++) {\n                    var subStatement = _a[_i];\n                    this.checkStatement(subStatement);\n                }\n                this.endBlock();\n            }\n        }\n    };\n    Walker.prototype.checkImportDeclaration = function (node) {\n        if (!tsutils_1.isStringLiteral(node.moduleSpecifier)) {\n            // Ignore grammar error\n            return;\n        }\n        var source = this.options.importSourcesOrderTransform(removeQuotes(node.moduleSpecifier.text));\n        this.checkSource(source, node);\n        var importClause = node.importClause;\n        if (importClause !== undefined && importClause.namedBindings !== undefined && tsutils_1.isNamedImports(importClause.namedBindings)) {\n            this.checkNamedImports(importClause.namedBindings);\n        }\n    };\n    Walker.prototype.checkImportEqualsDeclaration = function (node) {\n        // only allowed `import x = require('y');`\n        var moduleReference = node.moduleReference;\n        if (!tsutils_1.isExternalModuleReference(moduleReference)) {\n            return;\n        }\n        var expression = moduleReference.expression;\n        if (expression === undefined || !tsutils_1.isStringLiteral(expression)) {\n            return;\n        }\n        var source = this.options.importSourcesOrderTransform(removeQuotes(expression.text));\n        this.checkSource(source, node);\n    };\n    Walker.prototype.checkSource = function (source, node) {\n        var currentSource = this.options.moduleSourcePath(source);\n        var previousSource = this.currentImportsBlock.getLastImportSource();\n        this.currentImportsBlock.addImportDeclaration(this.sourceFile, node, currentSource);\n        if (previousSource !== null && compare(currentSource, previousSource) === -1) {\n            this.lastFix = [];\n            this.addFailureAtNode(node, Rule.IMPORT_SOURCES_UNORDERED, this.lastFix);\n        }\n    };\n    Walker.prototype.endBlock = function () {\n        if (this.lastFix !== undefined) {\n            var replacement = this.currentImportsBlock.getReplacement();\n            if (replacement !== undefined) {\n                this.lastFix.push(replacement);\n            }\n            this.lastFix = undefined;\n        }\n        this.importsBlocks.push(new ImportsBlock());\n    };\n    Walker.prototype.checkNamedImports = function (node) {\n        var _this = this;\n        var imports = node.elements;\n        var pair = findUnsortedPair(imports, this.options.namedImportsOrderTransform);\n        if (pair !== undefined) {\n            var a = pair[0], b = pair[1];\n            var sortedDeclarations = sortByKey(imports, function (x) {\n                return _this.options.namedImportsOrderTransform(x.getText());\n            }).map(function (x) { return x.getText(); });\n            // replace in reverse order to preserve earlier offsets\n            for (var i = imports.length - 1; i >= 0; i--) {\n                var start = imports[i].getStart();\n                var length = imports[i].getText().length;\n                // replace the named imports one at a time to preserve whitespace\n                this.currentImportsBlock.replaceNamedImports(start, length, sortedDeclarations[i]);\n            }\n            this.lastFix = [];\n            this.addFailure(a.getStart(), b.getEnd(), Rule.NAMED_IMPORTS_UNORDERED, this.lastFix);\n        }\n    };\n    Walker.prototype.checkBlocksGrouping = function () {\n        this.importsBlocks.some(this.checkBlockGroups, this);\n    };\n    Walker.prototype.checkBlockGroups = function (importsBlock) {\n        var oddImportDeclaration = this.getOddImportDeclaration(importsBlock);\n        if (oddImportDeclaration !== undefined) {\n            this.addFailureAtNode(oddImportDeclaration.node, Rule.IMPORT_SOURCES_NOT_GROUPED, this.getReplacements());\n            return true;\n        }\n        return false;\n    };\n    Walker.prototype.getOddImportDeclaration = function (importsBlock) {\n        var importDeclarations = importsBlock.getImportDeclarations();\n        if (importDeclarations.length === 0) {\n            return undefined;\n        }\n        var type = importDeclarations[0].type;\n        if (type < this.nextType) {\n            return importDeclarations[0];\n        }\n        else {\n            this.nextType = type;\n            return importDeclarations.find(function (importDeclaration) { return importDeclaration.type !== type; });\n        }\n    };\n    Walker.prototype.getReplacements = function () {\n        var _a;\n        var importDeclarationsList = this.importsBlocks\n            .map(function (block) { return block.getImportDeclarations(); })\n            .filter(function (imports) { return imports.length > 0; });\n        var allImportDeclarations = (_a = []).concat.apply(_a, importDeclarationsList);\n        var replacements = this.getReplacementsForExistingImports(importDeclarationsList);\n        var startOffset = allImportDeclarations.length === 0 ? 0 : allImportDeclarations[0].nodeStartOffset;\n        replacements.push(Lint.Replacement.appendText(startOffset, this.getGroupedImports(allImportDeclarations)));\n        return replacements;\n    };\n    Walker.prototype.getReplacementsForExistingImports = function (importDeclarationsList) {\n        var _this = this;\n        return importDeclarationsList.map(function (items, index) {\n            var start = items[0].nodeStartOffset;\n            if (index > 0) {\n                var prevItems = importDeclarationsList[index - 1];\n                var last = prevItems[prevItems.length - 1];\n                if (/[\\r\\n]+/.test(_this.sourceFile.text.slice(last.nodeEndOffset, start))) {\n                    // remove whitespace between blocks\n                    start = last.nodeEndOffset;\n                }\n            }\n            return Lint.Replacement.deleteFromTo(start, items[items.length - 1].nodeEndOffset);\n        });\n    };\n    Walker.prototype.getGroupedImports = function (importDeclarations) {\n        return [ImportType.LIBRARY_IMPORT, ImportType.PARENT_DIRECTORY_IMPORT, ImportType.CURRENT_DIRECTORY_IMPORT]\n            .map(function (type) {\n            var imports = importDeclarations.filter(function (importDeclaration) { return importDeclaration.type === type; });\n            return getSortedImportDeclarationsAsText(imports);\n        })\n            .filter(function (text) { return text.length > 0; })\n            .join(this.getEolChar());\n    };\n    Walker.prototype.getEolChar = function () {\n        var lineEnd = this.sourceFile.getLineEndOfPosition(0);\n        var newLine;\n        if (lineEnd > 0) {\n            if (lineEnd > 1 && this.sourceFile.text[lineEnd - 1] === \"\\r\") {\n                newLine = \"\\r\\n\";\n            }\n            else if (this.sourceFile.text[lineEnd] === \"\\n\") {\n                newLine = \"\\n\";\n            }\n        }\n        return newLine === undefined ? ts.sys.newLine : newLine;\n    };\n    return Walker;\n}(Lint.AbstractWalker));\nvar ImportsBlock = /** @class */ (function () {\n    function ImportsBlock() {\n        this.importDeclarations = [];\n    }\n    ImportsBlock.prototype.addImportDeclaration = function (sourceFile, node, sourcePath) {\n        var start = this.getStartOffset(node);\n        var end = this.getEndOffset(sourceFile, node);\n        var text = sourceFile.text.substring(start, end);\n        var type = this.getImportType(sourcePath);\n        if (start > node.getStart() || end === 0) {\n            // skip block if any statements don't end with a newline to simplify implementation\n            this.importDeclarations = [];\n            return;\n        }\n        this.importDeclarations.push({\n            node: node,\n            nodeEndOffset: end,\n            nodeStartOffset: start,\n            sourcePath: sourcePath,\n            text: text,\n            type: type,\n        });\n    };\n    ImportsBlock.prototype.getImportDeclarations = function () {\n        return this.importDeclarations;\n    };\n    // replaces the named imports on the most recent import declaration\n    ImportsBlock.prototype.replaceNamedImports = function (fileOffset, length, replacement) {\n        var importDeclaration = this.getLastImportDeclaration();\n        if (importDeclaration === undefined) {\n            // nothing to replace. This can happen if the block is skipped\n            return;\n        }\n        var start = fileOffset - importDeclaration.nodeStartOffset;\n        if (start < 0 || start + length > importDeclaration.node.getEnd()) {\n            throw new Error(\"Unexpected named import position\");\n        }\n        var initialText = importDeclaration.text;\n        importDeclaration.text = initialText.substring(0, start) + replacement + initialText.substring(start + length);\n    };\n    ImportsBlock.prototype.getLastImportSource = function () {\n        if (this.importDeclarations.length === 0) {\n            return null;\n        }\n        return this.getLastImportDeclaration().sourcePath;\n    };\n    // creates a Lint.Replacement object with ordering fixes for the entire block\n    ImportsBlock.prototype.getReplacement = function () {\n        if (this.importDeclarations.length === 0) {\n            return undefined;\n        }\n        var fixedText = getSortedImportDeclarationsAsText(this.importDeclarations);\n        var start = this.importDeclarations[0].nodeStartOffset;\n        var end = this.getLastImportDeclaration().nodeEndOffset;\n        return new Lint.Replacement(start, end - start, fixedText);\n    };\n    // gets the offset immediately after the end of the previous declaration to include comment above\n    ImportsBlock.prototype.getStartOffset = function (node) {\n        if (this.importDeclarations.length === 0) {\n            return node.getStart();\n        }\n        return this.getLastImportDeclaration().nodeEndOffset;\n    };\n    // gets the offset of the end of the import's line, including newline, to include comment to the right\n    ImportsBlock.prototype.getEndOffset = function (sourceFile, node) {\n        return sourceFile.text.indexOf(\"\\n\", node.end) + 1;\n    };\n    ImportsBlock.prototype.getLastImportDeclaration = function () {\n        return this.importDeclarations[this.importDeclarations.length - 1];\n    };\n    ImportsBlock.prototype.getImportType = function (sourcePath) {\n        if (sourcePath.charAt(0) === \".\") {\n            if (sourcePath.charAt(1) === \".\") {\n                return ImportType.PARENT_DIRECTORY_IMPORT;\n            }\n            else {\n                return ImportType.CURRENT_DIRECTORY_IMPORT;\n            }\n        }\n        else {\n            return ImportType.LIBRARY_IMPORT;\n        }\n    };\n    return ImportsBlock;\n}());\n// Convert aBcD --> AbCd\nfunction flipCase(str) {\n    return Array.from(str).map(function (char) {\n        if (char >= \"a\" && char <= \"z\") {\n            return char.toUpperCase();\n        }\n        else if (char >= \"A\" && char <= \"Z\") {\n            return char.toLowerCase();\n        }\n        return char;\n    }).join(\"\");\n}\n// After applying a transformation, are the nodes sorted according to the text they contain?\n// If not, return the pair of nodes which are out of order.\nfunction findUnsortedPair(xs, transform) {\n    for (var i = 1; i < xs.length; i++) {\n        if (transform(xs[i].getText()) < transform(xs[i - 1].getText())) {\n            return [xs[i - 1], xs[i]];\n        }\n    }\n    return undefined;\n}\nfunction compare(a, b) {\n    function isLow(value) {\n        return value[0] === \".\" || value[0] === \"/\";\n    }\n    if (isLow(a) && !isLow(b)) {\n        return 1;\n    }\n    else if (!isLow(a) && isLow(b)) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else if (a < b) {\n        return -1;\n    }\n    return 0;\n}\nfunction removeQuotes(value) {\n    // strip out quotes\n    if (value.length > 1 && (value[0] === \"'\" || value[0] === \"\\\"\")) {\n        value = value.substr(1, value.length - 2);\n    }\n    return value;\n}\nfunction getSortedImportDeclarationsAsText(importDeclarations) {\n    var sortedDeclarations = sortByKey(importDeclarations.slice(), function (x) { return x.sourcePath; });\n    return sortedDeclarations.map(function (x) { return x.text; }).join(\"\");\n}\nfunction sortByKey(xs, getSortKey) {\n    return xs.slice().sort(function (a, b) { return compare(getSortKey(a), getSortKey(b)); });\n}\nfunction moduleDeclarationBody(node) {\n    var body = node.body;\n    while (body !== undefined && body.kind === ts.SyntaxKind.ModuleDeclaration) {\n        body = body.body;\n    }\n    return body !== undefined && body.kind === ts.SyntaxKind.ModuleBlock ? body : undefined;\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/orderedImportsRule.js\n// module id = 2118\n// module chunks = 45"],"sourceRoot":""}