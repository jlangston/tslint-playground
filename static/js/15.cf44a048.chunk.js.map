{"version":3,"sources":["../node_modules/tslint/lib/rules/whitespaceRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","utils","ts","Lint","OPTION_BRANCH","OPTION_DECL","OPTION_OPERATOR","OPTION_MODULE","OPTION_SEPARATOR","OPTION_REST_SPREAD","OPTION_TYPE","OPTION_TYPECAST","OPTION_TYPE_OPERATOR","OPTION_PREBLOCK","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","ruleArguments","branch","has","decl","operator","module","separator","restSpread","type","typecast","typeOperator","preblock","option","indexOf","parseOptions","metadata","ruleName","description","rationale","optionsDescription","Utils","dedent","__makeTemplateObject","options","items","enum","minLength","maxLength","optionExamples","typescriptOnly","hasFix","FAILURE_STRING_MISSING","FAILURE_STRING_INVALID","Rules","AbstractRule","ctx","forEachChild","cb","node","kind","SyntaxKind","ArrowFunction","checkEqualsGreaterThanTokenInNode","BinaryExpression","_a","left","operatorToken","right","CommaToken","checkForTrailingWhitespace","getEnd","getFullStart","Block","ConditionalExpression","_b","condition","whenTrue","ConstructorType","ExportAssignment","position","getChildAt","FunctionType","ImportDeclaration","importClause","undefined","namedBindings_1","namedBindings","NamespaceImport","elements","forEach","element","idx","arr","internalName","name","length","getLastToken","startPos","getStart","ImportEqualsDeclaration","TypeAssertionExpression","expression","VariableDeclaration","PropertyDeclaration","_c","initializer","BindingElement","Parameter","dotDotDotToken","checkForExcessiveWhitespace","end","SpreadAssignment","SpreadElement","UnionType","IntersectionType","types_1","types","typeNode","index","prevTokenShouldBeFollowedByWhitespace","equalsGreaterThanToken","getChildOfKind","EqualsGreaterThanToken","whiteSpacePos","isWhiteSpace","text","charCodeAt","addMissingWhitespaceErrorAt","failures","some","f","getStartPosition","getPosition","fix","Replacement","appendText","addFailureAt","deleteText","addInvalidWhitespaceErrorAt","forEachTokenWithTrivia","_text","tokenKind","range","parent","WhitespaceTrivia","NewLineTrivia","EndOfFileToken","pos","CatchKeyword","ForKeyword","IfKeyword","SwitchKeyword","WhileKeyword","WithKeyword","SemicolonToken","nextPosition","ForStatement","EqualsToken","JsxAttribute","ColonToken","ImportKeyword","CallExpression","ExportKeyword","FromKeyword"],"mappings":"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","file":"static/js/15.cf44a048.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n// tslint:disable object-literal-sort-keys\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_BRANCH = \"check-branch\";\nvar OPTION_DECL = \"check-decl\";\nvar OPTION_OPERATOR = \"check-operator\";\nvar OPTION_MODULE = \"check-module\";\nvar OPTION_SEPARATOR = \"check-separator\";\nvar OPTION_REST_SPREAD = \"check-rest-spread\";\nvar OPTION_TYPE = \"check-type\";\nvar OPTION_TYPECAST = \"check-typecast\";\nvar OPTION_TYPE_OPERATOR = \"check-type-operator\";\nvar OPTION_PREBLOCK = \"check-preblock\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, parseOptions(this.ruleArguments));\n    };\n    Rule.metadata = {\n        ruleName: \"whitespace\",\n        description: \"Enforces whitespace style conventions.\",\n        rationale: \"Helps maintain a readable, consistent style in your codebase.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Ten arguments may be optionally provided:\\n\\n            * `\\\"check-branch\\\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace.\\n            * `\\\"check-decl\\\"`checks that variable declarations have whitespace around the equals token.\\n            * `\\\"check-operator\\\"` checks for whitespace around operator tokens.\\n            * `\\\"check-module\\\"` checks for whitespace in import & export statements.\\n            * `\\\"check-separator\\\"` checks for whitespace after separator tokens (`,`/`;`).\\n            * `\\\"check-rest-spread\\\"` checks that there is no whitespace after rest/spread operator (`...`).\\n            * `\\\"check-type\\\"` checks for whitespace before a variable type specification.\\n            * `\\\"check-typecast\\\"` checks for whitespace between a typecast and its target.\\n            * `\\\"check-type-operator\\\"` checks for whitespace between type operators `|` and `&`.\\n            * `\\\"check-preblock\\\"` checks for whitespace before the opening brace of a block\"], [\"\\n            Ten arguments may be optionally provided:\\n\\n            * \\\\`\\\"check-branch\\\"\\\\` checks branching statements (\\\\`if\\\\`/\\\\`else\\\\`/\\\\`for\\\\`/\\\\`while\\\\`) are followed by whitespace.\\n            * \\\\`\\\"check-decl\\\"\\\\`checks that variable declarations have whitespace around the equals token.\\n            * \\\\`\\\"check-operator\\\"\\\\` checks for whitespace around operator tokens.\\n            * \\\\`\\\"check-module\\\"\\\\` checks for whitespace in import & export statements.\\n            * \\\\`\\\"check-separator\\\"\\\\` checks for whitespace after separator tokens (\\\\`,\\\\`/\\\\`;\\\\`).\\n            * \\\\`\\\"check-rest-spread\\\"\\\\` checks that there is no whitespace after rest/spread operator (\\\\`...\\\\`).\\n            * \\\\`\\\"check-type\\\"\\\\` checks for whitespace before a variable type specification.\\n            * \\\\`\\\"check-typecast\\\"\\\\` checks for whitespace between a typecast and its target.\\n            * \\\\`\\\"check-type-operator\\\"\\\\` checks for whitespace between type operators \\\\`|\\\\` and \\\\`&\\\\`.\\n            * \\\\`\\\"check-preblock\\\"\\\\` checks for whitespace before the opening brace of a block\"]))),\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    \"check-branch\", \"check-decl\", \"check-operator\", \"check-module\", \"check-separator\",\n                    \"check-rest-spread\", \"check-type\", \"check-typecast\", \"check-type-operator\", \"check-preblock\",\n                ],\n            },\n            minLength: 0,\n            maxLength: 10,\n        },\n        optionExamples: [[true, \"check-branch\", \"check-operator\", \"check-typecast\"]],\n        type: \"style\",\n        typescriptOnly: false,\n        hasFix: true,\n    };\n    Rule.FAILURE_STRING_MISSING = \"missing whitespace\";\n    Rule.FAILURE_STRING_INVALID = \"invalid whitespace\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments) {\n    return {\n        branch: has(OPTION_BRANCH),\n        decl: has(OPTION_DECL),\n        operator: has(OPTION_OPERATOR),\n        module: has(OPTION_MODULE),\n        separator: has(OPTION_SEPARATOR),\n        restSpread: has(OPTION_REST_SPREAD),\n        type: has(OPTION_TYPE),\n        typecast: has(OPTION_TYPECAST),\n        typeOperator: has(OPTION_TYPE_OPERATOR),\n        preblock: has(OPTION_PREBLOCK),\n    };\n    function has(option) {\n        return ruleArguments.indexOf(option) !== -1;\n    }\n}\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ArrowFunction:\n                checkEqualsGreaterThanTokenInNode(node);\n                break;\n            // check for spaces between the operator symbol (except in the case of comma statements)\n            case ts.SyntaxKind.BinaryExpression: {\n                var _a = node, left = _a.left, operatorToken = _a.operatorToken, right = _a.right;\n                if (options.operator && operatorToken.kind !== ts.SyntaxKind.CommaToken) {\n                    checkForTrailingWhitespace(left.getEnd());\n                    checkForTrailingWhitespace(right.getFullStart());\n                }\n                break;\n            }\n            case ts.SyntaxKind.Block:\n                if (options.preblock) {\n                    checkForTrailingWhitespace(node.getFullStart());\n                }\n                break;\n            // check for spaces between ternary operator symbols\n            case ts.SyntaxKind.ConditionalExpression:\n                if (options.operator) {\n                    var _b = node, condition = _b.condition, whenTrue = _b.whenTrue;\n                    checkForTrailingWhitespace(condition.getEnd());\n                    checkForTrailingWhitespace(whenTrue.getFullStart());\n                    checkForTrailingWhitespace(whenTrue.getEnd());\n                }\n                break;\n            case ts.SyntaxKind.ConstructorType:\n                checkEqualsGreaterThanTokenInNode(node);\n                break;\n            case ts.SyntaxKind.ExportAssignment:\n                if (options.module) {\n                    var exportKeyword = node.getChildAt(0);\n                    var position = exportKeyword.getEnd();\n                    checkForTrailingWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.FunctionType:\n                checkEqualsGreaterThanTokenInNode(node);\n                break;\n            case ts.SyntaxKind.ImportDeclaration: {\n                var importClause = node.importClause;\n                if (options.module && importClause !== undefined) {\n                    // an import clause can have _both_ named bindings and a name (the latter for the default import)\n                    // but the named bindings always come last, so we only need to check that for whitespace\n                    var position = void 0;\n                    var namedBindings_1 = importClause.namedBindings;\n                    if (namedBindings_1 !== undefined) {\n                        if (namedBindings_1.kind !== ts.SyntaxKind.NamespaceImport) {\n                            namedBindings_1.elements.forEach(function (element, idx, arr) {\n                                var internalName = element.name;\n                                if (internalName !== undefined) {\n                                    if (idx === arr.length - 1) {\n                                        var token = namedBindings_1.getLastToken();\n                                        checkForTrailingWhitespace(token.getFullStart());\n                                    }\n                                    if (idx === 0) {\n                                        var startPos = internalName.getStart() - 1;\n                                        checkForTrailingWhitespace(startPos, startPos + 1);\n                                    }\n                                }\n                            });\n                        }\n                        position = namedBindings_1.getEnd();\n                    }\n                    else if (importClause.name !== undefined) {\n                        position = importClause.name.getEnd();\n                    }\n                    if (position !== undefined) {\n                        checkForTrailingWhitespace(position);\n                    }\n                }\n                break;\n            }\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n                if (options.module) {\n                    var position = node.name.getEnd();\n                    checkForTrailingWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.TypeAssertionExpression:\n                if (options.typecast) {\n                    var position = node.expression.getFullStart();\n                    checkForTrailingWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.VariableDeclaration:\n            case ts.SyntaxKind.PropertyDeclaration:\n                var _c = node, name = _c.name, type = _c.type, initializer = _c.initializer;\n                if (options.decl && initializer !== undefined) {\n                    checkForTrailingWhitespace((type !== undefined ? type : name).getEnd());\n                }\n                break;\n            case ts.SyntaxKind.BindingElement:\n            case ts.SyntaxKind.Parameter:\n                var dotDotDotToken = node.dotDotDotToken;\n                if (options.restSpread && dotDotDotToken !== undefined) {\n                    checkForExcessiveWhitespace(dotDotDotToken.end);\n                }\n                break;\n            case ts.SyntaxKind.SpreadAssignment:\n            case ts.SyntaxKind.SpreadElement:\n                if (options.restSpread) {\n                    var position = node.expression.getFullStart();\n                    checkForExcessiveWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.UnionType:\n            case ts.SyntaxKind.IntersectionType:\n                if (options.typeOperator) {\n                    var types_1 = node.types;\n                    types_1.forEach(function (typeNode, index) {\n                        if (index > 0) {\n                            checkForTrailingWhitespace(typeNode.getFullStart());\n                        }\n                        if (index < types_1.length - 1) {\n                            checkForTrailingWhitespace(typeNode.getEnd());\n                        }\n                    });\n                }\n        }\n        ts.forEachChild(node, cb);\n    });\n    var prevTokenShouldBeFollowedByWhitespace = false;\n    utils.forEachTokenWithTrivia(sourceFile, function (_text, tokenKind, range, parent) {\n        if (tokenKind === ts.SyntaxKind.WhitespaceTrivia ||\n            tokenKind === ts.SyntaxKind.NewLineTrivia ||\n            tokenKind === ts.SyntaxKind.EndOfFileToken) {\n            prevTokenShouldBeFollowedByWhitespace = false;\n            return;\n        }\n        else if (prevTokenShouldBeFollowedByWhitespace) {\n            addMissingWhitespaceErrorAt(range.pos);\n            prevTokenShouldBeFollowedByWhitespace = false;\n        }\n        // check for trailing space after the given tokens\n        switch (tokenKind) {\n            case ts.SyntaxKind.CatchKeyword:\n            case ts.SyntaxKind.ForKeyword:\n            case ts.SyntaxKind.IfKeyword:\n            case ts.SyntaxKind.SwitchKeyword:\n            case ts.SyntaxKind.WhileKeyword:\n            case ts.SyntaxKind.WithKeyword:\n                if (options.branch) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.CommaToken:\n                if (options.separator) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.SemicolonToken:\n                if (!options.separator) {\n                    break;\n                }\n                var nextPosition = range.pos + 1;\n                var semicolonInTrivialFor = parent.kind === ts.SyntaxKind.ForStatement &&\n                    nextPosition !== sourceFile.end &&\n                    (sourceFile.text[nextPosition] === \";\" || sourceFile.text[nextPosition] === \")\");\n                if (!semicolonInTrivialFor) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.EqualsToken:\n                if (options.decl && parent.kind !== ts.SyntaxKind.JsxAttribute) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.ColonToken:\n                if (options.type) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.ImportKeyword:\n                if (parent.kind === ts.SyntaxKind.CallExpression &&\n                    parent.expression.kind === ts.SyntaxKind.ImportKeyword) {\n                    return; // Don't check ImportCall\n                }\n            // falls through\n            case ts.SyntaxKind.ExportKeyword:\n            case ts.SyntaxKind.FromKeyword:\n                if (options.typecast) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n        }\n    });\n    function checkEqualsGreaterThanTokenInNode(node) {\n        if (!options.operator) {\n            return;\n        }\n        var equalsGreaterThanToken = utils.getChildOfKind(node, ts.SyntaxKind.EqualsGreaterThanToken, sourceFile);\n        // condition so we don't crash if the arrow is somehow missing\n        if (equalsGreaterThanToken === undefined) {\n            return;\n        }\n        checkForTrailingWhitespace(equalsGreaterThanToken.getFullStart());\n        checkForTrailingWhitespace(equalsGreaterThanToken.getEnd());\n    }\n    function checkForTrailingWhitespace(position, whiteSpacePos) {\n        if (whiteSpacePos === void 0) { whiteSpacePos = position; }\n        if (position !== sourceFile.end && !Lint.isWhiteSpace(sourceFile.text.charCodeAt(position))) {\n            addMissingWhitespaceErrorAt(whiteSpacePos);\n        }\n    }\n    function addMissingWhitespaceErrorAt(position) {\n        // TODO: this rule occasionally adds duplicate failures.\n        if (ctx.failures.some(function (f) { return f.getStartPosition().getPosition() === position; })) {\n            return;\n        }\n        var fix = Lint.Replacement.appendText(position, \" \");\n        ctx.addFailureAt(position, 1, Rule.FAILURE_STRING_MISSING, fix);\n    }\n    function checkForExcessiveWhitespace(position) {\n        if (position !== sourceFile.end && Lint.isWhiteSpace(sourceFile.text.charCodeAt(position))) {\n            addInvalidWhitespaceErrorAt(position);\n        }\n    }\n    function addInvalidWhitespaceErrorAt(position) {\n        var fix = Lint.Replacement.deleteText(position, 1);\n        ctx.addFailureAt(position, 1, Rule.FAILURE_STRING_INVALID, fix);\n    }\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/whitespaceRule.js\n// module id = 2151\n// module chunks = 15"],"sourceRoot":""}